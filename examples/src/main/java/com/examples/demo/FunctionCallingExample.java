/**
 * Copyright (c) 2025 Oracle and/or its affiliates.
 * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/
 */
package com.examples.demo;

import java.io.IOException;
import java.time.Duration;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.openai.client.OpenAIClient;
import com.openai.core.JsonValue;
import com.openai.models.responses.FunctionTool;
import com.openai.models.responses.Response;
import com.openai.models.responses.ResponseCreateParams;
import com.openai.models.responses.ResponseFunctionToolCall;
import com.openai.models.responses.ResponseInputContent;
import com.openai.models.responses.ResponseInputItem;
import com.openai.models.responses.ResponseInputText;
import com.openai.models.responses.ResponseOutputItem;
import com.openai.models.responses.ResponseOutputMessage;
import com.openai.models.responses.ResponseOutputText;
import com.openai.models.responses.Tool;
import com.oracle.genai.openai.OciOpenAI;

public final class FunctionCallingExample {
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
    private static final TypeReference<Map<String, Object>> MAP_TYPE = new TypeReference<>() {
    };
    private static final List<Tool> HOROSCOPE_TOOLS = createHoroscopeTools();
    private static final String COMPARTMENT_ID = "<YOUR COMPARTMENT_ID>";
    private static final String BASE_URL = "https://inference.generativeai.us-chicago-1.oci.oraclecloud.com/actions/v1";
    private static final String CONVERSATION_STORE_ID = "<YOUR CONVERSATION_STORE_ID>";

    private FunctionCallingExample() {
    }

    public static void main(String[] args) throws Exception {
        OpenAIClient client = createClient();
        String model = "openai.gpt-4.1";

        List<ResponseInputItem> inputList = new ArrayList<>();
        inputList.add(createUserMessage("What is my horoscope? I am an Aquarius."));

        try {
            Response firstResponse = client.responses().create(ResponseCreateParams.builder()
                    .model(model)
                    .tools(HOROSCOPE_TOOLS)
                    .input(ResponseCreateParams.Input.ofResponse(inputList))
                    .build());

            appendOutputItems(inputList, firstResponse);

            handleFunctionCalls(inputList, firstResponse);

            System.out.println("Final input:");
            System.out.println(OBJECT_MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(inputList));

            Response finalResponse = client.responses().create(ResponseCreateParams.builder()
                    .model(model)
                    .instructions("Respond only with a horoscope generated by a tool.")
                    .tools(HOROSCOPE_TOOLS)
                    .input(ResponseCreateParams.Input.ofResponse(inputList))
                    .build());

            System.out.println("Final output:");
            System.out.println(OBJECT_MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(finalResponse));

            List<String> outputTexts = extractTextOutputs(finalResponse);
            if (!outputTexts.isEmpty()) {
                System.out.println();
                outputTexts.forEach(System.out::println);
            }
        } finally {
            client.close();
        }
    }

    private static OpenAIClient createClient() throws Exception {
        return OciOpenAI.builder()
                .compartmentId(COMPARTMENT_ID)
                .conversationStoreId(CONVERSATION_STORE_ID)
                .authType("security_token")
                .baseUrl(BASE_URL)
                .profile("DEFAULT")
                .timeout(Duration.ofMinutes(2))
                .build();
    }

    private static ResponseInputItem createUserMessage(String content) {
        ResponseInputText inputText = ResponseInputText.builder()
                .text(content)
                .build();

        ResponseInputItem.Message message = ResponseInputItem.Message.builder()
                .role(ResponseInputItem.Message.Role.USER)
                .content(List.of(ResponseInputContent.ofInputText(inputText)))
                .build();

        return ResponseInputItem.ofMessage(message);
    }

    private static void appendOutputItems(List<ResponseInputItem> inputList, Response response) {
        for (ResponseOutputItem item : response.output()) {
            if (item.isMessage()) {
                inputList.add(ResponseInputItem.ofResponseOutputMessage(item.asMessage()));
            } else if (item.isFunctionCall()) {
                inputList.add(ResponseInputItem.ofFunctionCall(item.asFunctionCall()));
            }
        }
    }

    private static void handleFunctionCalls(List<ResponseInputItem> inputList, Response response) throws IOException {
        for (ResponseOutputItem item : response.output()) {
            if (!item.isFunctionCall()) {
                continue;
            }

            ResponseFunctionToolCall functionCall = item.asFunctionCall();
            Map<String, Object> arguments = parseArguments(functionCall.arguments());
            String sign = Optional.ofNullable(arguments.get("sign"))
                    .map(Object::toString)
                    .orElseThrow(() -> new IllegalArgumentException("Missing required argument 'sign'"));

            String horoscope = getHoroscope(sign);
            Map<String, Object> payload = new LinkedHashMap<>();
            payload.put("horoscope", horoscope);

            ResponseInputItem.FunctionCallOutput functionCallOutput = ResponseInputItem.FunctionCallOutput.builder()
                    .callId(functionCall.callId())
                    .output(OBJECT_MAPPER.writeValueAsString(payload))
                    .build();

            inputList.add(ResponseInputItem.ofFunctionCallOutput(functionCallOutput));
        }
    }

    private static Map<String, Object> parseArguments(String json) throws IOException {
        if (json == null || json.isBlank()) {
            return Map.of();
        }
        return OBJECT_MAPPER.readValue(json, MAP_TYPE);
    }

    private static List<String> extractTextOutputs(Response response) {
        List<String> texts = new ArrayList<>();
        for (ResponseOutputItem item : response.output()) {
            if (!item.isMessage()) {
                continue;
            }
            ResponseOutputMessage message = item.asMessage();
            for (ResponseOutputMessage.Content content : message.content()) {
                if (content.isOutputText()) {
                    ResponseOutputText outputText = content.asOutputText();
                    texts.add(outputText.text());
                }
            }
        }
        return texts;
    }

    private static List<Tool> createHoroscopeTools() {
        FunctionTool.Parameters parameters = FunctionTool.Parameters.builder()
                .putAdditionalProperty("type", JsonValue.Companion.from("object"))
                .putAdditionalProperty("properties", JsonValue.Companion.from(createHoroscopeSchema()))
                .putAdditionalProperty("required", JsonValue.Companion.from(List.of("sign")))
                .putAdditionalProperty("additionalProperties", JsonValue.Companion.from(false))
                .build();

        FunctionTool horoscopeTool = FunctionTool.builder()
                .name("get_horoscope")
                .description("Get today's horoscope for an astrological sign.")
                .parameters(parameters)
                .strict(true)
                .build();

        return List.of(Tool.ofFunction(horoscopeTool));
    }

    private static Map<String, Object> createHoroscopeSchema() {
        Map<String, Object> sign = new LinkedHashMap<>();
        sign.put("type", "string");
        sign.put("description", "An astrological sign like Taurus or Aquarius");

        Map<String, Object> properties = new LinkedHashMap<>();
        properties.put("sign", sign);
        return properties;
    }

    private static String getHoroscope(String sign) {
        return sign + ": Next Tuesday you will befriend a baby otter.";
    }
}
